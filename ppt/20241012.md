# 几何特征

## **几何编码矩阵的建立**：

​	对每个实体建立一个边框，统计重叠数量，考虑10类实体，一张图就是10个节点，每个节点算一个实体类，每个节点维度：1（该实体类，剩余不重叠的数量）+10（该实体类和其它实体类重叠的数量，自身类与自身类重叠数量为0）组成，即该节点对于所有其它实体的重叠数量和该实体类不重叠的实体数量=>几何编码矩阵体现了实体间的位置，实体类之间的关联强度，实体类的数量（并不是直接这个实体类有多少的数量，而是重叠与不重叠的数量）

## **邻接矩阵的建立：**

若某类实体重叠某类实体发生重叠，则建立一条边

## **重叠数量的计算**：

- **边界框计算**：对每个实体建立一个边界框（先简化处理，获得上、下、左、右四个坐标）。
  - 对于：POLYLINE，ELLIPS，我们的数据集没有这两种，SPLINE只有极少数有1个，只考虑下述10种，（需要更精细的处理）
    - INSERT （块引用，是可复用的实体组合，还是很重要的，SOLID都是位于INSERT内）：遍历块中的实体，计算其边界框（需不需）
    - LINE：将起点和终点作为边界框的两个极端点
    - TEXT ：文本的插入位置 `(x, y)`，文本的高度和宽度，默认是横向或竖向，如果是斜的，就不精确
    - MTEXT 
    - HATCH ：遍历填充实体的边界路径，取边界路径的关键点
    - LWPOLYLINE ：将所有顶点添加到 `points` 列表中。通过计算 `points` 中的最小和最大坐标，得到边界框。
    - LEADER ：获取引线的顶点
    - CIRCLE：圆的边界框是其外接正方形
    - DIMENSION：（计算重叠不够精确）收集标注的关键点：（需不需要？）
      - `def_point`：定义点，通常是标注的基准点。
      - `text_midpoint`：标注文字的中点。
      - `dim_line_point`：标注线的位置。
    - ARC：采样圆弧上的点，通过 `points` 列表中的点，计算最小和最大坐标，得到边界框

- 使用**空间索引**：**R 树（R-tree）**，来减少需要进行重叠检查的实体对数量。

- **归一化**：对于特征矩阵的每一行，将自身类对应的自身类放在第一列，后续列为固定顺序的其它实体类，对第一列的所有行进行列归一化（利用起不同实体类，数量不同），对后续列的每一行进行行归一化，有少数只有一两个实体重叠，则归一化后为0，这样就无需在这两类之间建立边

![image-20241006170635483](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241006170635483.png)

- **特殊说明：**

  - 计算没考虑自定义块内的实体（仅仅考虑模型空间中的实体），自定义块只有需要插入模型空间中，才能通过INSERT引用，没插入模型空间时，只作为预定义的形式存在
  - 后面尝试下把INSERT内部的实体一起考虑进来，看看效果
  - 后续看看分割DXF文件需不需优化

  - ![image-20241009104930868](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241009104930868.png)

  # 丰富数据集

## 原因:数据太少

- MGMN需要同一类多个数据，CGMN不需要，因为它只取MGMN的部分模块并且改了损失函数，变成对比学习的方式，损失函数就不需要标签了，但是我们还是采用自然语言处理中的dropout技术，对特征进行随机遮蔽的做法，随机舍弃一些节点的与其它节点的重叠情况，这样一份dxf文件，得到不同的节点间的重叠情况，得到不同的邻接矩阵，但它们是相似的，归为同一类，我们取6次随机遮蔽，这样数据集从1份变成6份，从89->6*89

## 具体做法：

- 对第一种归一化方法的提取编码矩阵除第一列的后续列，形成新的矩阵TEMP，对TEMP进行6次随机遮盖特征，形成若干个TEMP1，TEMP2，TEMP3,  TEMP4, TEMP5, TEMP6

- 把TEMP1，TEMP2,  TEMP3,   TEMP4, TEMP5, TEMP6大于0的元素视为有边，进一步转化为邻接表adj1,adj2,adj3,adj4, adj5,adj6

- 把这些TEMP1，TEMP2,  TEMP3,   TEMP4, TEMP5, TEMP6与原先的第一列拼接，形成f1，f2，f3, f4, f5, f6作为新的编码矩阵，这些编码矩阵都属于来自同一份dxf文件

- 随机遮盖特征的做法：dropout取0.1=>  f1，f2，f3, f4, f5, f6

  ![image-20241009124717268](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241009124717268.png)

  # CGMN模块的结果
  
  ## 我们的相关指标：
  
  ![image-20241010121904492](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010121904492.png)
  
  ![image-20241010121919208](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010121919208.png)
  
  ![image-20241010121933667](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010121933667.png)
  
  ![image-20241010113515440](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010113515440.png)
  
  ## 原始论文相关指标：
  
  ![image-20241010113022268](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010113022268.png)
  
  ## 下面仅仅是简单的测试，测试用的DXF文件，模型在训练，验证，测试时是没有见过的
  
  ### 使用扩展后的数据集测量相似度
  
  #### 同一类6份dxf之间的相似度（以QFN22LD(Cu)-532Rev1_2.dxf为基准）
  
  ![image-20241010132421465](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010132421465.png)
  
  我们认为同一张DXF文件扩展利用随机去掉一些边和节点得到的6份DXF数据，是属于同一类的，结果也证实了这一点的合理性
  
  #### 不同类之间的相似度（以"QFN22LD(Cu)-532Rev1_3.dxf为基准）
  
  ![image-20241010132320652](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010132320652.png)
  
  ![image-20241010120039243](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010120039243.png)
  
  ![image-20241010120100804](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010120100804.png)
  
  ![image-20241010120116075](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010120116075.png)
  
  ![image-20241010120200510](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010120200510.png)
  
  ![image-20241010120243985](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010120243985.png)
  
  
  
  # 网络结构
  
  - MGMN
  
    - ![img](https://api2.mubu.com/v3/document_image/55cbeee9-e48f-4b64-b0e7-da155495554d-20117527.jpg)
    - SimGNN
  
    - ![img](https://api2.mubu.com/v3/document_image/98495830-484e-48f0-b920-a3a9fe478883-20117527.jpg)
  
    - CGMN
  
      - CGMN将MGMN的loss改动就变成了自监督
  
    - ![image-20241012083633605](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012083633605.png)
  
    - ![image-20241012083701367](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012083701367.png)
  
    - 添加了视图（图增强）的跨级特征提取
  
      - 每一个视图的节点具有另外一个视图全部节点的信息以及另一张图全部节点的信息
  
      ![image-20241010072655081](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010072655081.png)
  
      - CGMN的正负对:同一份DXF文件，生成两个视图，对这两个视图的正样本对（在一个视图中某个节点，正样本对就是同一份DXF产生的另外一个视图的对应位置的节点），相似度最大化，负样本对相似度最小化（负样本对定义为，一个视图中某一个点，它的负样本对就是它和这个视图的其它节点（不包括自身和自身），以及同一份DXF产生的另外一个视图的所有节点）
  
    # 序列特征
  
    ## 句柄
  
    ![image-20241012095538263](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012095538263.png)
  
    ### 原因：
  
    ​	DXF文件的实体句柄的值从小到大表示该实体添加入DXF文件的顺序，反映了设计意图和因果关系，某些实体的存在可能是其他实体存在的前提条件
  
    ### 处理方式：
  
    1. 预处理：因为我们输入的DXF文件并不是完整的一份DXF文件，而是分割后的DXF文件，这样造成句柄值并不是连续的，例如：MTEXT的句柄值为C0DB5，而下一个实体LEADER句柄值为D13E3，我们需要将下一个实体LEADER句柄值处理为C0DB6
  
    2. 数值化：将十六进制的句柄值转换为十进制数。
  
    3. 归一化：使用min-max归一化将句柄值映射到[0, 1]区间。
  
    ### 可视化结果
  
    ![entities_by_handle](C:\srtp\encode\second\entities_by_handle.png)
  
    ![entities_by_type](C:\srtp\encode\second\entities_by_type.png)
  
    
  
    ![image-20241010223047562](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010223047562.png)
  
    ## 融合方法
  
    ### 最直接的方式
  
    ​	一个实体类视为一个节点，每个节点考虑下述特征：聚类数量（该实体类型的聚类数量），平均聚类密度（所有聚类的平均密度），聚类密度方差（反映密度分布的均匀程度），最大聚类间距（最远两个聚类中心之间的距离），最小聚类间距（最近两个聚类中心之间的距离），聚类间距方差（反映聚类分布的均匀程度），首次出现时间，最后出现时间.....
  
    ​	把句柄得到的序列编码矩阵拼接到之前的几何编码矩阵之后
  
    ## **邻接矩阵的第二种建立方式**：
  
    边的条数和之前会比之前那种方法建立边的条数会更少一点（差不多10个点，10~20条）先利用相关模型检测出异常，然后剔除，最后如果一个实体前是另一种实体，或者一个实体后是另一种实体，则在这两个实体间建立一条边
  
    ![image-20241010215437446](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010215437446.png)
  
    # ContrastCAD
  
    [ContrastCAD: Contrastive Learning-based Representation Learning for Computer-Aided Design Models (arxiv.org)](https://arxiv.org/html/2404.01645?_immersive_translate_auto_translate=1)，202404 IEEE ACCESS
  
    ![image-20241012091437098](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012091437098.png)
  
    ## 目的：
  
    ​	生成多样化，全新的CAD（利用latent-GAN生成（输入标准噪声数据到模型（训练好的基于Transform的自编码器）中生成）
  
    ## 相似之处：
  
    “相同的 CAD 模型可以使用不同的 CAD 构建顺序来表示“这和我们的句柄数据差不多，不同的句柄数据确实可以表示相同的CAD
  
    ## 特点：
  
    ​	**输入序列的处理方式**：
  
    ![image-20241012092304358](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012092304358.png)
  
    一份CAD命令序列由若干条命令组成，论文中代码命令条数设置最大为60条，每一条命令，包含命令编码（用数字表示），参数编码：将所有命令的设计的参数全部调出来，在这个命令中有就填，没有就0，位置编码：这条命令在整个序列中的位置
  
    ![image-20241011211203210](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241011211203210.png)
  
    ![image-20241011210148854](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241011210148854.png)
  
    ​	基于 **Transformer 的自编码器模型**：将序列映射到具有语义信息的特征空间
  
    ​	**对比学习**：在嵌入空间中创建正对（相同文件，但应用了不同的掩膜）和负对（不同的文件）来实现对比学习。CGMN的正负对是在节点层面的，ContrastCAD是在整个文件上的
  
    ​	**损失函数：**
  
    ![image-20241012091921418](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012091921418.png)
  
    ​	**判别指标**：使用聚类作为判别指标
  
    ## 拟处理方式
  
    ​	1.先处理掉异常的（找一找相关方法）
  
    ​	2.我们的数据大多是是两三百个实体，有出现1700的，先定一个固定值，把长度大于固定值的删掉，然后先看看直接设置512行不行，如何行，就不需要改动
  
    ​	 否则我们考虑分层，下面那层（小窗口）使用（CAD Embedding）,在CAD Embedding和Transformer Encoder之间添加一个模块，作为上层，比如我们要对整个句柄序列分40个小窗口，一个窗口大小就是（总长/40），对一个窗口内使用（CAD Embedding），然后整个窗口用MLP处理到一个特征向量，每个小窗口拼起来就是Transformer Encoder的输入
  
    # 模型粗稿
  
    ![image-20241012095316702](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012095316702.png)
  
    ## 来源：
  
    几何特征矩阵
  
    ![image-20241010072655081](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241010072655081.png)
  
    序列特征矩阵
  
    ![image-20241012095038003](C:\Users\15653\AppData\Roaming\Typora\typora-user-images\image-20241012095038003.png)
  
    
  
    # 计划
  
    1.先处理掉异常的（找一找相关方法）
  
    ## 2.句柄序列编码
  
    ### 2.1 实体参数
  
    HATCH 特征:
  
    {'pattern_name': 'ANSI31', 'solid_fill': 0, 'associative': 0, 'boundary_paths': 8}
    {'pattern_name': 'ANSI31', 'solid_fill': 0, 'associative': 1, 'boundary_paths': 4}
  
    pattern_name: 填充图案名称
  
    solid_fill: 是否为实体填充， 0 表示非实体填充,即使用图案填充
  
    associative: 是否为关联填充，0 表示非关联填充,1 表示关联填充。关联填充意味着填充边界与其他实体（如线、圆等）相关联。当这些边界实体发生变化时，填充会自动更新以匹配新的边界。
  
    'boundary_paths'：边界路径数量指的是定义填充区域的封闭轮廓的数量
  
    
  
    
  
    TEXT 特征:
    {'text': 'HALF ETCH ON BOTTOM', 'insert_point': Vec3(396.0818019561805, 139.6943445264609, 0.0), 'height': 0.08, 'rotation': 0}
  
    text: 文本内容
  
    insert_point: 插入点坐标
  
    height: 文字高度
  
    rotation: 旋转角度
  
    
  
    MTEXT 特征:
    {'text': 'FULL METAL', 'insert_point': Vec3(404.1361941913078, 142.9183805374713, 0.0), 'char_height': 0.06666666, 'width': 0.6219441976340474, 'rotation': 0}
  
    text: 多行文本内容
  
    insert_point: 插入点坐标
  
    char_height: 字符高度
  
    width: 文本框宽度
  
    
  
    LWPOLYLINE 特征:
    {'closed': True, 'points': [(395.819853154926, 139.6625137883657, 0.0, 0.0, 0.0), (395.9806541764283, 139.6625137883657, 0.0, 0.0, 0.0), (395.9806541764283, 139.8233148098681, 0.0, 0.0, 0.0), (395.819853154926, 139.8233148098681, 0.0, 0.0, 0.0)], 'count': 4}
  
    closed: 是否闭合
  
    points: 多段线的点列表
  
    count: 点的数量
  
    
  
    ARC 特征:
    {'center': Vec3(398.8221825223083, 143.4364333052549, 0.0), 'radius': 0.11875, 'start_angle': 180.0, 'end_angle': 90.0}
  
    center: 圆心坐标
  
    radius: 半径
  
    start_angle: 起始角度
  
    end_angle: 结束角度
  
    
  
    LINE 特征:
    {'start_point': Vec3(398.9971825223084, 143.5551833052549, 0.0), 'end_point': Vec3(398.5440575223073, 143.5551833052551, 0.0)}
  
    start_point: 线段的起点坐标
  
    end_point: 线段的终点坐标
  
    
  
    CIRCLE 特征:
    {'center': Vec3(398.8221825223083, 142.9364333052549, 0.0), 'radius': 0.11875}
  
    center: 圆心坐标
  
    radius: 半径
  
    
  
    DIMENSION 特征:
    {'defpoint': Vec3(400.3284325223083, 146.1966954184052, 0.0), 'text_midpoint': Vec3(399.7003075223083, 146.1966954184052, 0.0), 'dim_type': 0}
  
    defpoint: 定义点坐标
  
    text_midpoint: 文本中点坐标
  
    dim_type: 标注类型
  
    
  
    LEADER 特征:
    {'vertices': [(398.2190951127764, 141.8598343414721, 0.0), (396.7597151407759, 140.0412732757189, 0.0), (395.7713643418502, 140.0412732757189, 0.0)], 'annotation_type': 3}
  
    vertices: 引线的顶点列表
  
    annotation_type: 注释类型
  
    
  
    INSERT 特征:
    {'name': '*U121', 'insert_point': Vec3(384.5059270744619, 143.5915590496204, 0.0), 'scale': (1, 1, 1), 'rotation': 0}
  
    name: 插入块的名称
  
    insert_point: 插入点的坐标
  
    scale: X、Y、Z方向的缩放比例
  
    rotation: 旋转角度
  
    
  
    3.ContrastCAD模块的测试或者添加Embding
  
    4.将几何特征和序列特征两个方向改成完整的一个模型
  
    ​	
  
    
  
    
  
    
  
    
  
    ​		
  
    
  
  - 
  
  
  
  















​		